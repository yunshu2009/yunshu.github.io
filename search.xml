<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入学习HTML5/CSS页面]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0HTML5%3ACSS%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[一些参考腾讯互娱前端开发规范 http://tgideas.qq.com/doc/frontend/]]></content>
  </entry>
  <entry>
    <title><![CDATA[年度记录]]></title>
    <url>%2F2018%2F05%2F19%2F%E5%B9%B4%E5%BA%A6%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[2018读书 《GO语言程序设计》 0% 《流畅的Python》 《图解算法》 《人月神话》 38% 《构建高性能的web站点》 《数据结构C语言版》（陈峰棋编） 《淘宝技术这十年》 47% 《计算机网络原理》 《运筹学基础》 《中国近代史》 《颠覆者-周鸿祎自传》 100% 《小狗钱钱》 100% 文档与视频Laravel 《L01 Laravel 教程 - Web 开发实战入门 ( Laravel 5.5 )》 https://laravel-china.org/courses/laravel-essential-training-5.5 100% 《L02 Laravel 教程 - Web 开发实战进阶 ( Laravel 5.5 )》《https://laravel-china.org/courses/laravel-advance-training-5.5》 《L03 Laravel 教程 - 实战构架 API 服务器》 《优才全栈培训视频》 电影《肖申克的救赎》100% 《千与千寻》 100% 看过的动漫《CLANNAD》 https://www.bilibili.com/bangumi/play/ep34492]]></content>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5 “$this->redirect()” 到底经历了啥]]></title>
    <url>%2F2018%2F04%2F07%2Fthinkphp5-source-reading%2F</url>
    <content type="text"><![CDATA[redirect方法，可以在自定义的控制器实现跳转的功能。看thinkphp 5.1源码发现它是在在jump trait中定义的一个方法。 Controller.php 12345678910111213141516171819202122232425...use traits\controller\Jump;class Controller&#123; use Jump; /** * 视图类实例 * @var \think\View */ protected $view; /** * Request实例 * @var \think\Request */ protected $request;...&#125; jump.php 可以看到它抛出一个异常 12345678910111213141516171819202122232425262728293031323334353637&lt;?php...namespace traits\controller;use think\Container;use think\exception\HttpResponseException;use think\Response;use think\response\Redirect;trait Jump&#123; . . . protected function redirect($url, $params = [], $code = 302, $with = []) &#123; $response = new Redirect($url); if (is_integer($params)) &#123; $code = $params; $params = []; &#125; $response-&gt;code($code)-&gt;params($params)-&gt;with($with); throw new HttpResponseException($response); &#125; . . . &#125; 查看HttpResponseException可以发现它是Excepton的子类 HttpResponseException.php 1234567891011121314151617181920&lt;?phpnamespace think\exception;use think\Response;class HttpResponseException extends \RuntimeException&#123; protected $response; public function __construct(Response $response) &#123; $this-&gt;response = $response; &#125; public function getResponse() &#123; return $this-&gt;response; &#125;&#125; RuntimeException是SPL中的类,它继承Exception12class RuntimeException extends Exception &#123;&#125; 到此我们知道了redirect()方法其实是抛出一个异常，那它是在哪里调用然后输出（跳转）呢？ 从入口文件index.php开始。发现先加载base.php，然后执行App类的run方法。然后调用返回对象的send方法 12345678910&lt;?phpnamespace think;// 加载基础文件require __DIR__ . &apos;/../thinkphp/base.php&apos;;// 支持事先使用静态方法设置Request对象和Config对象// 执行应用并响应Container::get(&apos;app&apos;)-&gt;run()-&gt;send(); App类,发现它catch了一个HttpResponseException，返回Redirect类型的Response 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?phpnamespace think;use think\exception\ClassNotFoundException;use think\exception\HttpResponseException;use think\route\Dispatch;/** * App 应用管理 */class App implements \ArrayAccess&#123; const VERSION = &apos;5.1.5&apos;; . . . // 执行应用程序 public function run() &#123; // 初始化应用 $this-&gt;initialize(); try &#123; if ($this-&gt;bind) &#123; // 模块/控制器绑定 $this-&gt;route-&gt;bind($this-&gt;bind); &#125; elseif ($this-&gt;config(&apos;app.auto_bind_module&apos;)) &#123; // 入口自动绑定 $name = pathinfo($this-&gt;request-&gt;baseFile(), PATHINFO_FILENAME); if ($name &amp;&amp; &apos;index&apos; != $name &amp;&amp; is_dir($this-&gt;appPath . $name)) &#123; $this-&gt;route-&gt;bind($name); &#125; &#125; // 读取默认语言 $this-&gt;lang-&gt;range($this-&gt;config(&apos;app.default_lang&apos;)); if ($this-&gt;config(&apos;app.lang_switch_on&apos;)) &#123; // 开启多语言机制 检测当前语言 $this-&gt;lang-&gt;detect(); &#125; $this-&gt;request-&gt;langset($this-&gt;lang-&gt;range()); // 加载系统语言包 $this-&gt;lang-&gt;load([ $this-&gt;thinkPath . &apos;lang/&apos; . $this-&gt;request-&gt;langset() . &apos;.php&apos;, $this-&gt;appPath . &apos;lang/&apos; . $this-&gt;request-&gt;langset() . &apos;.php&apos;, ]); // 监听app_dispatch $this-&gt;hook-&gt;listen(&apos;app_dispatch&apos;); // 获取应用调度信息 $dispatch = $this-&gt;dispatch; if (empty($dispatch)) &#123; // 进行URL路由检测 $dispatch = $this-&gt;routeCheck(); &#125; // 记录当前调度信息 $this-&gt;request-&gt;dispatch($dispatch); // 记录路由和请求信息 if ($this-&gt;debug) &#123; $this-&gt;log(&apos;[ ROUTE ] &apos; . var_export($this-&gt;request-&gt;routeInfo(), true)); $this-&gt;log(&apos;[ HEADER ] &apos; . var_export($this-&gt;request-&gt;header(), true)); $this-&gt;log(&apos;[ PARAM ] &apos; . var_export($this-&gt;request-&gt;param(), true)); &#125; // 监听app_begin $this-&gt;hook-&gt;listen(&apos;app_begin&apos;); // 请求缓存检查 $this-&gt;request-&gt;cache( $this-&gt;config(&apos;app.request_cache&apos;), $this-&gt;config(&apos;app.request_cache_expire&apos;), $this-&gt;config(&apos;app.request_cache_except&apos;) ); // 执行调度 $data = $dispatch-&gt;run(); &#125; catch (HttpResponseException $exception) &#123; $data = $exception-&gt;getResponse(); &#125; $this-&gt;middlewareDispatcher-&gt;add(function (Request $request, $next) use ($data) &#123; // 输出数据到客户端 if ($data instanceof Response) &#123; $response = $data; &#125; elseif (!is_null($data)) &#123; // 默认自动识别响应输出类型 $isAjax = $request-&gt;isAjax(); $type = $isAjax ? $this-&gt;config(&apos;app.default_ajax_return&apos;) : $this-&gt;config(&apos;app.default_return_type&apos;); $response = Response::create($data, $type); &#125; else &#123; $response = Response::create(); &#125; return $response; &#125;); $response = $this-&gt;middlewareDispatcher-&gt;dispatch($this-&gt;request); // 监听app_end $this-&gt;hook-&gt;listen(&apos;app_end&apos;, $response); return $response; &#125; . . .&#125; 继续看Redirect类父类Response的send方法。它设置了header头等 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php namespace think;use think\response\Redirect as RedirectResponse;class Response&#123; . . . /** * 发送数据到客户端 * @access public * @return void * @throws \InvalidArgumentException */ public function send() &#123; // 监听response_send Container::get(&apos;hook&apos;)-&gt;listen(&apos;response_send&apos;, $this); // 处理输出数据 $data = $this-&gt;getContent(); // Trace调试注入 if (Container::get(&apos;env&apos;)-&gt;get(&apos;app_trace&apos;, Container::get(&apos;app&apos;)-&gt;config(&apos;app.app_trace&apos;))) &#123; Container::get(&apos;debug&apos;)-&gt;inject($this, $data); &#125; if (200 == $this-&gt;code &amp;&amp; $this-&gt;allowCache) &#123; $cache = Container::get(&apos;request&apos;)-&gt;getCache(); if ($cache) &#123; $this-&gt;header[&apos;Cache-Control&apos;] = &apos;max-age=&apos; . $cache[1] . &apos;,must-revalidate&apos;; $this-&gt;header[&apos;Last-Modified&apos;] = gmdate(&apos;D, d M Y H:i:s&apos;) . &apos; GMT&apos;; $this-&gt;header[&apos;Expires&apos;] = gmdate(&apos;D, d M Y H:i:s&apos;, $_SERVER[&apos;REQUEST_TIME&apos;] + $cache[1]) . &apos; GMT&apos;; Container::get(&apos;cache&apos;)-&gt;tag($cache[2])-&gt;set($cache[0], [$data, $this-&gt;header], $cache[1]); &#125; &#125; if (!headers_sent() &amp;&amp; !empty($this-&gt;header)) &#123; // 发送状态码 http_response_code($this-&gt;code); // 发送头部信息 foreach ($this-&gt;header as $name =&gt; $val) &#123; header($name . (!is_null($val) ? &apos;:&apos; . $val : &apos;&apos;)); &#125; &#125; $this-&gt;sendData($data); if (function_exists(&apos;fastcgi_finish_request&apos;)) &#123; // 提高页面响应 fastcgi_finish_request(); &#125; // 监听response_end Container::get(&apos;hook&apos;)-&gt;listen(&apos;response_end&apos;, $this); // 清空当次请求有效的数据 if (!($this instanceof RedirectResponse)) &#123; Container::get(&apos;session&apos;)-&gt;flush(); &#125; &#125; . . .&#125; 最后应用终止时会执行shutdown处理方法。它在Error.php已经注册了shutdown方法为Error类的appShutdown方法 1234567891011121314151617&lt;?php class Error &#123; . . . public static function register() &#123; error_reporting(E_ALL); set_error_handler([__CLASS__, &apos;appError&apos;]); set_exception_handler([__CLASS__, &apos;appException&apos;]); register_shutdown_function([__CLASS__, &apos;appShutdown&apos;]); &#125; . . .&#125; appShutdown方法 123456789101112public static function appShutdown()&#123; if (!is_null($error = error_get_last()) &amp;&amp; self::isFatal($error[&apos;type&apos;])) &#123; // 将错误信息托管至think\ErrorException $exception = new ErrorException($error[&apos;type&apos;], $error[&apos;message&apos;], $error[&apos;file&apos;], $error[&apos;line&apos;]); self::appException($exception); &#125; // 写入日志 Container::get(&apos;log&apos;)-&gt;save();&#125; OK. 另：thinkphp 5.0源码阅读参考：https://www.kancloud.cn/zmwtp/tp5/155311]]></content>
      <tags>
        <tag>php,thankphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库扩展]]></title>
    <url>%2F2018%2F04%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[复制和分离主从复制复制原理: master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）； slave将master的binary log events拷贝到它的中继日志(relay log)； slave重做中继日志中的事件。 复制过程对于主服务器的影响非常有限。当存在多个从服务器同时从一个主武器进行复制的时候，主服务器的磁盘压力会有不同程度额增长，可以采用多级复制策略解决。 读写分离对于查询操作比较密集的站点，将读操作分配给从服务器，写操作分配给主服务器。 mysqlroute数据库反向代理mysqlroute工作在应用程序和mysql服务器之间，负责所有请求和响应数据的转发。mysqlroute会将应用的读请求分配到主服务器上，将写请求分配到从服务器上，最后将结果返回给应用，在开始时只需要对mysqlroute做一些配置即可。 也可以使用Mycat数据库中间件 垂直分区当数据库写操作频繁的站点来说，可以采用垂直分区来解决。 将不同类型的数据库转移到独立的数据库服务器上，然后又可以对分出去的数据库做主从复制来实现读写分离。 水平分区当通过垂直分区后，数据库的主服务器再次无法承受写操作压力时，我们可以将同一数据表中的记录通过特定的算法进行分离，分别保存到不同的数据库表中，从而可以部署到不同的服务器服务器上。 分区和分表在分区之前要先分表，分表只是单台数据库的优化策略。为了让数据库的可扩展，便需要考虑分区，将表迁移到其它的数据库服务器上。 分片策略分片字段的选择：一般选择数据表的主键，但得保证不能使用auto_increment自增类型，可以自己实现一个id生成器（使用redis可实现）。 哈希算法可以采用取模的方式，数据分布均匀，扩容要成倍扩容，2台服务器扩展到4台服务器。 范围会造成访问不均的情况。 时间适合归档性质的数据。 映射关系映射表维护比较麻烦。 分区反向代理 MyCAT 官网：http://www.mycat.io/ Spock Proxy 关系型数据库瓶颈 缓存 全文检索 方案1：xunsearch http://www.xunsearch.com/ 方案2：Elasticsearch Elasticsearch入门教程参考： http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html NOSQL]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018技术书单]]></title>
    <url>%2F2018%2F03%2F30%2F2018%E6%8A%80%E6%9C%AF%E4%B9%A6%E5%8D%95%2F</url>
    <content type="text"><![CDATA[新的一年要开始重视计算机基础知识的学习了，只有基础扎实了，才能走更远，今年技术类书单： 《深入理解计算机系统》 《现代操作系统》 《C程序设计语言》 《数据结构与算法分析（C 语言描述）》 《Unix环境高级编程》 《UNIX 网络编程》 《TCP/IP网络通信详解》 《Java面向对象编程》 《Java编程思想》 《go语言程序设计》 《高性能MySQL》 不要求一定看完，但要求一定要看，将巩固计算基础作为一项长期的目标~ 另外多看源码（比如Laravel源码、php源码），多做开源项目，提高工程能力~ 休息时间，可以看看动漫，哈哈~~~]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站性能优化]]></title>
    <url>%2F2018%2F03%2F25%2F%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端优化减少http请求数 图片地图。客户单图片地图可以使用map标签来实现。如果正在导航或者其他超链接中使用多个图片，将他们转换为图片地图是加速页面的最简单的方式。 CSS Sprites。将多幅图片合并成单独的图片。使用CSS的background-position属性，可以将HTML元素放置到背景图片期望的位置上。 内联图片。使用data:URL模式可以在Web页面中包含图片但无需额外的HTTP请求。 合并脚本和样式表。理想情况下，一个页面应该使用不多于一个脚本和样式表。 使用CDN存储前端资源CDN用于发布静态内容，如图片、脚本、样式和Flash。 可使用http://17ce.com这个网站网站使用CDN后在各地的响应速度。 添加Expires头充分利用浏览器缓存多域名访问前端资源使用单独的静态资源域名。资源数据的压缩压缩代码大小、图片大小，开启服务器gzip压缩优化首屏展示速度 延迟加载、异步加载 扩展阅读： 雅虎34条军规 Yslow Web性能测试插件 php优化使用opcode缓存opcode缓存简介 当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码（Operate Code，opcode）。Opcode cache的目地是避免重复编译，减少CPU和内存开销。如果动态内容的性能瓶颈不在于CPU和内存，而在于I/O操作，比如数据库查询带来的磁盘I/O开销，那么opcode cache的性能提升是非常有限的。 使用opcode缓存 从图中可以看出，使用了opcode缓存后，php代码的生命周期少了词典扫描和表达式（将PHP代码转换为语言片段[Tokens]）、解析文件（将Tokens转换成简单而有意义的表达式）、创建要执行的计算机代码（称为Opcode）几步。 opecode缓存-Zend OPcache安装使用PHP&gt;=5.5.0，php内置了OPcache,PHP小于5.5.0的话，要通过PCEL安装。 OPcache配置 123456789101112#检查脚本时间戳是否有更新的周期，以秒为单位。 设置为0会导致针对每个请求，OPcache都会检查脚本更新。opcache.revalidate_freq=60#如果启用，那么 OPcache 会每隔 opcache.revalidate_freq 设定的秒数 检查脚本是否更新。 如果禁用此选项，你必须使用 opcache_reset() 或者 opcache_invalidate() 函数来手动重置 OPcache，也可以 通过重启 Web 服务器来使文件系统更改生效opcache.validate_timestamps=1 #OPcache 哈希表中可存储的脚本文件数量上限。 真实的取值是在质数集合 &#123; 223, 463, 983, 1979, 3907, 7963, 16229, 32531, 65407, 130987 &#125; 中找到的第一个大于等于设置值的质数。 设置值取值范围最小值是 200，最大值在 PHP 5.5.6 之前是 100000，PHP 5.5.6 及之后是 1000000opcache.max_accelerated_files=1000#OPcache 的共享内存大小，以兆字节为单位。opcache.memory_consumption=512# 用来存储预留字符串的内存大小，以兆字节为单位。 PHP 5.3.0 之前的版本会忽略此配置指令。opcache.interned_strings_buffer=16#如果启用，则会使用快速停止续发事件。 所谓快速停止续发事件是指依赖 Zend 引擎的内存管理模块 一次释放全部请求变量的内存，而不是依次释放每一个已分配的内存块。opcache.fast_shutdown=1 PHP 7PHP 7相对比PHP 5.*,性能有了质的飞跃。PHP7相对于php5.6有2~3倍的性能提升。目前PHP的最新版本是PHP 7.2.5，相对于PHP 7.1也有部分性能提升。 性能评测文章参考： PHP的性能演进(从PHP5.0到PHP7.1的性能全评测PHP7.2、PHP7.1 性能对比 SWOOLE… php性能分析 xhui + tideways实践 tiways是一个测试php性能的php扩展，php版本要求是大于等于7.0。如果php版本小于7.0，可以使用xhprof扩展。xhgui用来展示测试数据，xhgui将数据保存到MongoDB。 安装tideways在ubuntu环境下： 1234echo &apos;deb http://s3-eu-west-1.amazonaws.com/qafoo-profiler/packages debian main&apos; &gt; /etc/apt/sources.list.d/tideways.listwget -qO - https://s3-eu-west-1.amazonaws.com/qafoo-profiler/packages/EEB5E8F4.gpg | sudo apt-key add -sudo apt-get updatesudo apt-get install tideways-php tideways-daemon 重启php-fpm，查看是否安装成功： 1sudo service php7.1-fpm restart 安装MongoDB123sudo apt-get install mongodbsudo apt-get install php-mongodbsudo /etc/init.d/mongodb start 安装xhgui123git clone https://github.com/laynefyc/xhgui-branch.gitcd xhgui-branchcomposer install 配置xhgui添加config/config.php,添加支持扩展为tideways 123return [ &apos;extension&apos; =&gt; &apos;tideways&apos;,]; MongoDB加索引1234567$ mongo &gt; use xhprof &gt; db.results.ensureIndex( &#123; &apos;meta.SERVER.REQUEST_TIME&apos; : -1 &#125; ) &gt; db.results.ensureIndex( &#123; &apos;profile.main().wt&apos; : -1 &#125; ) &gt; db.results.ensureIndex( &#123; &apos;profile.main().mu&apos; : -1 &#125; ) &gt; db.results.ensureIndex( &#123; &apos;profile.main().cpu&apos; : -1 &#125; ) &gt; db.results.ensureIndex( &#123; &apos;meta.url&apos; : 1 &#125; ) 配置nginx 1.要监控的应用 123456789101112131415161718 location ~ \.php$ &#123; fastcgi_split_path_info ^(.+\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #加上下面的这两句 fastcgi_param TIDEWAYS_SAMPLERATE &quot;25&quot;; fastcgi_param PHP_VALUE &quot;auto_prepend_file=/home/vagrant/Code/xhgui/external/header.php&quot;; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300;&#125; 2.分析平台应用 12345678910#表示省略了一些nginx配置server &#123; listen 80; listen 443 ssl http2; server_name xhgui.app; root &quot;/home/vagrant/Code/xhgui/webroot&quot;; . . .&#125; 性能分析平台搭建效果 相关链接 ： https://github.com/tideways/php-xhprof-extension https://tideways.io/profiler/docs/setup/installation https://github.com/laynefyc/xhgui-branch.git 使用XHProf查找PHP性能瓶颈 Mysql优化表的设计优化 添加主键索引 innodb需要有一个主键，主键不要有业务用途。 表的字段类型选择 能选短整形，就不要选长整型 能选char就避免varchar 使用varchar类型的时候，长度够用就行 大字段考虑分开存储 字段适当冗余 索引的优化 索引不要建太多 在修改数据时，每个索引都要进行更新，降低写速度。 explain分析sql语句的执行计划 示例： 123456&gt; explain select * from typecho_contents where cid=40;+----+-------------+------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+| 1 | SIMPLE | typecho_contents | NULL | const | PRIMARY | PRIMARY | 4 | const | 1 | 100.00 | NULL |+----+-------------+------------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+ 重要列： type - 连接使用的类型 链接类型从最佳到最坏：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL 解释： system:表仅有一行(=系统表)。这是const联接类型的一个特例。 const:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次! eq_ref:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。 ref:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。 ref_or_null:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。 index_merge:该联接类型表示使用了索引合并优化方法。 unique_subquery:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。 index_subquery:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) range:只检索给定范围的行,使用一个索引来选择行。 index:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。 一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。 key: Mysql实际使用的索引 Extra: Using filesort: Mysql需要额外的步骤排序，表示语句需要优化 Using temporary： 使用到临时表来存储查询结果，表示语句需要优化 SQL查询优化通过慢查询日志获取存在性能问题的SQL慢查询日志分析工具相关配置参数 12345678slow_query_log # 启动停止记录慢查日志，慢查询日志默认是没有开启的可以在配置文件中开启(on)slow_query_log_file # 指定慢查日志的存储路径及文件，日志存储和数据存储应该分开存储long_query_time # 指定记录慢查询日志SQL执行时间的阀值默认值为10秒通常,对于一个繁忙的系统来说,改为0.001秒(1毫秒)比较合适log_queries_not_using_indexes # 是否记录未使用索引的SQL 工具：pt-query-digest 1pt-query-digest --explain h=127.0.0.1,u=root,p=123456 slow-mysql.log pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog。可以把分析结果输出到文件中，也可以对SHOW PROCESSLIST或者通过tcpdump抓取的MySQL协议数据进行分析。分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题。 pt-query-digest工具的安装 因为pt-query-digest是包含在percona-tookit工具集中的，所以只要安装percona-tookit即可。percona-tookie链接：https://www.percona.com/doc/percona-toolkit/3.0/installation.html pt-query-digest工具的使用参考 https://www.cnblogs.com/luyucheng/p/6265873.html 实时获取存在性能问题的SQL直接通过表查询1234SELECT id,user,host,DB,command,time,state,infoFROM information_schema.processlistWHERE TIME&gt;=1 查询当前服务器执行超过1s的SQL，可以通过脚本周期性的来执行这条SQL，就能查出有问题的SQL。 通过pt-query-digst来分析1pt-query-digest --processlist h=host1 特定SQL的查询优化大表的数据修改大彪删除/更新100万或者更多1000万行记录，一次只删除/更新5000行记录，中间暂停几秒。 大表的结构在线修改添加一个新表（修改后的结构），老表数据导入新表，老表建立触发器，修改数据同步到新表， 老表加一个排它锁（重命名）， 新表重命名， 删除老表。 可以借助pt-online-schema-change工具来完成。 pt-oneline-schema-change 工具使用参考： https://blog.csdn.net/lovelichao12/article/details/73549939 优化not in和&lt;&gt;查询子查询改写为关联查询 12345select id,name from a where id not in (select id from b) 改写后： 12345select id,name from a left join b on a.id=b.idwhere b.id is null Mysql参考书籍： 《高性能mysql》 《MySQL 技术内幕：InnoDB 存储引擎》 《数据库索引设计与优化》 Nginx优化… 待完善…]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库学习总结]]></title>
    <url>%2F2018%2F03%2F20%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关系型数据库关系型数据库的三范式第一范式（1NF）: 每一列都是不可分割的原子数据项(基本类型列) 第二范式（2NF）： 要求实体的属性完全依赖于主关键字(无重复行) 第三范式（3NF）: 数据表不包含其它表已有的非主属性(无数据冗余) 关于数据库的规范设计，都会谈到是否符合三范式。但是考虑到数据库的性能优化，也不必都按照三范式来设计，可以做数据的适当冗余。如为了查询效率，在商品表，可以设置个img_url字段放图片的主图。 MySQL本质了解mysql逻辑架构 1.最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。 2.第二层架构主要完成大多的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询表的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。 3.存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。 4.数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。 MySQL核心模块 • Server Initialization Module 命令行、配置文件解析、内存分配 • Connection Manager 协议监听和协议转发 • Thread Manager 新建线程处理请求 • Connection Thread 新建新的,或者从线程缓存中去取 • User Authentication Module 验证用户身份 • Access Control Module 访问控制 • Parser 接收请求,解析进入命令分发或者进入查询 • Command Dispatcher 解析器分发给命令分发器 • Query Cache Module 查询缓存检查(SELECT、DELETE、UPDATE) • Optimizer 查询优化器 • Table Manager 打开表,获取锁 • Table Modification Modules 表更新 • Table Maintenance Module 表维护 • Status Reporting Module 状态报告 • Abstracted Storage Engine Interface (Table Handler) 抽象引擎接口 • Storage Engine Implementations (MyISAM, InnoDB...) 存储引擎实现 • Logging Module 日志记录 • Replication Master Module 复制主模块 • Replication Slave Module 复制从模块 • Client/Server Protocol API 客户端、服务器协议 API • Low-Level Network I/O API 底层网络 I/O API • Core API 核心 API 存储引擎的区别和选择存储引擎是mysql提供的文件访问层的一个抽象接口来定制一种文件访问机制。 mysql的存储引擎包括:MyISAM、InnoDB、BDB、MEMORY、MERGE、EXAMPLE、NDBCluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等。 MyISAM:不支持事务,支持全文索引,表级锁；数据文件全量备份，可以直接拷贝数据文件进行备份；适合处理读频率远大于写频率的静态表。 InnoDB:支持事务,5.6以后支持全文索引,默认行级锁；数据文件两种形式(单一文件形式和多文件形式,以共享表空间与独占表空间存储)；适用于高并发读写。 MySQL InnoDB的存储文件参考：http://blog.csdn.net/chenjiayi_yun/article/details/45533909 MySQL插件NoSql 插件 HandlerSocket 中文全文索引插件 mysqlcft （mysql5.7内置有n-gram parser插件） InnoDB引擎中的Memcached插件 MySQL中的事务事务的ACID:• 原子性(Atomicity ) 全部执行或全部不执行 • 一致性( Consistency ) 事务前后数据都是一致性状态,约束等 • 隔离性或独立性( Isolation) 事务之间是独立的,和级别相关 • 持久性(Durabilily) 事务完成即持久化存储 MysSQL锁表类型1- 表级锁(MyISAM) 开销小,加锁快;不会出现死锁;锁定粒 度大,发生锁冲突的概率最高,并发度最低 可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： mysql> show status like 'table%'; +-----------------------+-------+ | Variable_name | Value | +-----------------------+-------+ | Table_locks_immediate | 2979 | | Table_locks_waited | 0 | +-----------------------+-------+ 2 rows in set (0.00 sec)) 如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。 MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。锁模式的兼容性如表20-1所示。 MySQL中的表锁兼容性 请求锁模式 是否兼容 当前锁模式 None 读锁 写锁 读锁 是 是 否 写锁 是 否 否 行级锁(InnoDB) 开销大,加锁慢;会出现死锁;锁定粒度最 小,发生锁冲突的概率最低,并发度也最高 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： mysql> show status like 'innodb_row_lock%'; +-------------------------------+-------+ | Variable_name | Value | +-------------------------------+-------+ | InnoDB_row_lock_current_waits | 0 | | InnoDB_row_lock_time | 0 | | InnoDB_row_lock_time_avg | 0 | | InnoDB_row_lock_time_max | 0 | | InnoDB_row_lock_waits | 0 | +-------------------------------+-------+ 5 rows in set (0.01 sec) 如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。 页面锁 开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定 粒度界于表锁和行锁之间,并发度一般 使用悲观锁和乐观锁解决并发悲观锁在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。 乐观锁乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 参考： mysql悲观锁总结和实践 mysql乐观锁总结和实践 深入理解乐观锁与悲观锁 海量数据的分页优化方案 建立合适的索引 使用Redis缓存count,根据访问热度缓存靠后的分页数据 查找出limit的开始行id，然后用where拼接，如：where id&gt;*** limit 0,99 产品设计优化 MySQL的安装与配置MySQL源码安装下面在CentOS环境下安装、参考Oneinstack 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# 下载mysql源码包wget -4 --tries=6 -c --no-check-certificate https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/mysql-5.7.21.tar.gz# 进入软件目录pushd /opt/software/src# 添加mysql用户useradd -M -s /sbin/nologin mysql# 创建mysql的安装目录mkdir -p /usr/local/mysql# 创建mysql data目录mkdir -p /data/mysql# 更改mysql data目录权限chown mysql.mysql -R /data/mysqltar xzf mysql-5.7.21.tar.gzpushd mysql-5.7.21cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql \ -DSYSCONFDIR=/etc \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DWITH_PARTITION_STORAGE_ENGINE=1 \ -DWITH_FEDERATED_STORAGE_ENGINE=1 \ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \ -DWITH_MYISAM_STORAGE_ENGINE=1 \ -DWITH_EMBEDDED_SERVER=1 \ -DENABLE_DTRACE=0 \ -DENABLED_LOCAL_INFILE=1 \ -DDEFAULT_CHARSET=utf8mb4 \ -DDEFAULT_COLLATION=utf8mb4_general_ci \ -DEXTRA_CHARSETS=all \ -DCMAKE_EXE_LINKER_FLAGS=&apos;-ljemalloc&apos;makemake installpopdrm -rf mysql-5.7.21cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqldsed -i &quot;s@^basedir=.*@basedir=/usr/local/mysql@&quot; /etc/init.d/mysqldsed -i &quot;s@^datadir=.*@datadir=/data/mysql@&quot; /etc/init.d/mysqldchmod +x /etc/init.d/mysqldchkconfig --add mysqldchkconfig mysqld on# 添加mysql配置 cat &gt; /etc/my.cnf &lt;&lt; EOF[client]port = 3306socket = /tmp/mysql.sockdefault-character-set = utf8mb4[mysql]prompt=&quot;MySQL [\\d]&gt; &quot;no-auto-rehash[mysqld]port = 3306socket = /tmp/mysql.sockbasedir = /usr/local/mysqldatadir = /data/mysqlpid-file = /data/mysql/mysql.piduser = mysqlbind-address = 0.0.0.0server-id = 1init-connect = &apos;SET NAMES utf8mb4&apos;character-set-server = utf8mb4skip-name-resolve#skip-networkingback_log = 300max_connections = 1000max_connect_errors = 6000open_files_limit = 65535table_open_cache = 128max_allowed_packet = 500Mbinlog_cache_size = 1Mmax_heap_table_size = 8Mtmp_table_size = 16Mread_buffer_size = 2Mread_rnd_buffer_size = 8Msort_buffer_size = 8Mjoin_buffer_size = 8Mkey_buffer_size = 4Mthread_cache_size = 8query_cache_type = 1query_cache_size = 8Mquery_cache_limit = 2Mft_min_word_len = 4log_bin = mysql-binbinlog_format = mixedexpire_logs_days = 7log_error = /dta/mysql/mysql-error.logslow_query_log = 1long_query_time = 1slow_query_log_file = /data/mysql/mysql-slow.logperformance_schema = 0explicit_defaults_for_timestamp#lower_case_table_names = 1skip-external-lockingdefault_storage_engine = InnoDB#default-storage-engine = MyISAMinnodb_file_per_table = 1innodb_open_files = 500innodb_buffer_pool_size = 64Minnodb_write_io_threads = 4innodb_read_io_threads = 4innodb_thread_concurrency = 0innodb_purge_threads = 1innodb_flush_log_at_trx_commit = 2innodb_log_buffer_size = 2Minnodb_log_file_size = 32Minnodb_log_files_in_group = 3innodb_max_dirty_pages_pct = 90innodb_lock_wait_timeout = 120bulk_insert_buffer_size = 8Mmyisam_sort_buffer_size = 8Mmyisam_max_sort_file_size = 10Gmyisam_repair_threads = 1interactive_timeout = 28800wait_timeout = 28800[mysqldump]quickmax_allowed_packet = 500M[myisamchk]key_buffer_size = 8Msort_buffer_size = 8Mread_buffer = 4Mwrite_buffer = 4MEOF# 数据库初始化/usr/local/mysql/bin/mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysqlchown mysql.mysql -R /data/mysqlservice mysqld start# 设置环境变量echo &quot;export PATH=/usr/local/mysql/bin:\$PATH&quot; &gt;&gt; /etc/profile[ -z &quot;$(grep ^&apos;export PATH=&apos; /etc/profile)&quot; ] &amp;&amp; echo &quot;export PATH=/usr/local/mysql/bin:\$PATH&quot; &gt;&gt; /etc/profile[ -n &quot;$(grep ^&apos;export PATH=&apos; /etc/profile)&quot; -a -z &quot;$(grep /usr/local/mysql /etc/profile)&quot; ] &amp;&amp; sed -i &quot;s@^export PATH=\(.*\)@export PATH=/usr/local/mysql/bin:\1@&quot; /etc/profile# 设置密码/usr/local/mysql/bin/mysql -e &quot;grant all privileges on *.* to root@&apos;127.0.0.1&apos; identified by &quot;123456&quot; with grant option;&quot;/usr/local/mysql/bin/mysql -e &quot;grant all privileges on *.* to root@&apos;localhost&apos; identified by &quot;123456&quot; with grant option;&quot;# 添加动态链接库echo &quot;/usr/local/mysql/lib&quot; &gt; /etc/ld.so.conf.d/mysql.confldconfigservice mysqld restart MySQL源码目录 • BUILD 编译脚本 • client 命令行工具代码(mysql,mysqladmin) • cmd-line-utils 增强命令行的第三方库 (libedit 如 readline). • dbug 调试库 • libevent 由于 5.6 支持 某个插件的库 • plugin 插件所在的库 • libmysql MySQL 的库,其他客户端,经如C/PHP 访问MySQL需 要引用这个目录的库 • mysys 核心可移植性或者工具API • regex 正则表达式库 • scripts 脚本库,如 mysqld_safe 所在 • sql MySQL 的核心所在,用C++所写 • sql-common 客户端、服务器能用代码 • strings 字符串库 • storage 存储引擎所在的库 • vio 底层网络I/O操作库 • zlib库 数据库配置优化基础配置连接数配置通过show variables like &#39;%conn%&#39;;查看配置 max_connections 设置整个服务器最大session连接数 max_user_connections 每个用户的session连接个数,值为0时表示每个用户的连接数不受限制 网络配置skip-name-resolve：禁止掉DNS的查询 解释：mysql会在用户登录过程中对客户端IP进行DNS反查，不管你是使用IP登录还是域名登录，这个反查的过程都是在的。所以如果你的mysql所在的服务器的DNS有问题或者质量不好，那么就有可能造成127.0.0.1登录很快，用域名或者IP登录数据库很慢的DNS解析问题。 数据库加这个参数速度会变快skip-name-resolve，但是也有注意点，mysql.user 表里面的host不要用localhost之类的，要用127.0.0.1，不然连自己都连不上数据库，会报错。 缓存配置查询缓存查询缓存的作用就是当查询接收到一个和之前同样的查询，服务器将会从查询缓存种检索结果，而不是再次分析和执行上次的查询。这样就大大提高了性能，节省时间。当查询很大、更新很少的情况下可以使用查询缓存。 查看缓存设置1show variables like &apos;%query_cache%&apos;; 输出如下： +------------------------------+---------+ | Variable_name | Value | +------------------------------+---------+ | have_query_cache | YES | | query_cache_limit | 1048576 | | query_cache_min_res_unit | 4096 | | query_cache_size | 1048576 | | query_cache_type | OFF | | query_cache_wlock_invalidate | OFF | +------------------------------+---------+ 查看缓存的状态使用show status like &#39;%Qcache%&#39;; 输出结果： +-------------------------+---------+ | Variable_name | Value | +-------------------------+---------+ | Qcache_free_blocks | 1 | | Qcache_free_memory | 1031832 | | Qcache_hits | 0 | | Qcache_inserts | 0 | | Qcache_lowmem_prunes | 0 | | Qcache_not_cached | 4 | | Qcache_queries_in_cache | 0 | | Qcache_total_blocks | 1 | +-------------------------+---------+ 参考：mysql查询缓存打开、设置、参数查询、性能变量意思 日志配置通用查询日志通用查询日志：记录建立的客户端连接和执行的语句 1). 查看通用查询日志配置1show variables like &apos;%general%&apos;; 输出结果： +------------------+------------------------------+ | Variable_name | Value | +------------------+------------------------------+ | general_log | OFF | | general_log_file | /data/mysql/xxxxxx.log | +------------------+------------------------------+ 通用查询日志默认是关闭的。 2). 查看当前日志输出的格式 1MySQL [(none)]&gt; show variables like &apos;%log_output%&apos;; 输出结果： +---------------+-------+ | Variable_name | Value | +---------------+-------+ | log_output | FILE | +---------------+-------+ 1 row in set (0.01 sec) 日志格式可以是FILE（存储在数数据库的数据文件中的hostname.log），也可以是TABLE（存储在数据库中的mysql.general_log） 3) 开启通用查询日志的方式 通过set命令设置，只对当前mysql生效，重启失效 12set global general_log=on;set global log_output=&apos;TABLE&apos;; # 值为“FILE”、“TABLE“或者“FILE,TABLE” 通过配置文件my.cnf配置 12general_log=1 # 为1表示开启通用日志查询，值为0表示关闭通用日志查询log_output=FILE,TABLE # 设置通用日志的输出格式为文件和表 慢查询日志MySQL的慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中（日志可以写入文件或者数据库表，如果对性能要求高的话，建议写文件）。默认情况下，MySQL数据库是不开启慢查询日志的，long_query_time的默认值为10（即10秒，通常设置为1秒），即运行10秒以上的语句是慢查询语句。 1) 查看是否开启慢查询日志 1show variables like &apos;%quer%&apos;; 输出结果中 slow_query_log值为ON时表示开启 slow_query_log_file 的值是记录的慢查询日志到文件中（注意：默认名为主机名.log，慢查询日志是否写入指定文件中，需要指定慢查询的输出日志格式为文件，相关命令为：show variables like ‘%log_output%’；去查看输出的格式。当设置为TABLE时，慢查询日志输出至mysql.slow_log中） 2) 在配置文件中配置慢查询 123slow_query_log = 1long_query_time = 1slow_query_log_file = /data/mysql/mysql-slow.log 3) 如何制造慢查询，看慢查询设置是否有效 1&gt; select sleep(5) 二进制配置主要作数据库的恢复和同步使用 123log_bin = mysql-binbinlog_format = mixedexpire_logs_days = 7 错误日志1log_error = /data/mysql/mysql-error.log]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PsySH-好用的php交互式控制台]]></title>
    <url>%2F2018%2F03%2F19%2FPsySH-%E5%A5%BD%E7%94%A8%E7%9A%84php%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%8E%A7%E5%88%B6%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[参考：PsySH——PHP交互式控制台]]></content>
  </entry>
  <entry>
    <title><![CDATA[Redis的数据类型以及使用场景]]></title>
    <url>%2F2018%2F02%2F25%2FRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[参考：https://mengkang.net/356.html]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让github上fork的项目同步原项目]]></title>
    <url>%2F2018%2F02%2F24%2F%E8%AE%A9github%E4%B8%8Afork%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1234567891011121314## 先clone到本地仓库git clone https://github.com/yunshu2009/think.git## 保持和远程仓库同步git remote add upstream https://github.com/top-think/think.git## 拉取远程仓库最新代码git fetch upstream## 合并到本地仓库git merge upstream/master## 及时更新最新改动git pull --rebase]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SSR科学上网]]></title>
    <url>%2F2018%2F02%2F19%2F%E4%BD%BF%E7%94%A8SSR%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[使用一键安装脚本安装shadowsocksR参考：https://shadowsocks.be/9.html 123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 在CentOS 7上安装BBR加速参考： 部署方法：https://www.vultr.com/docs/how-to-deploy-google-bbr-on-centos-7) 一键安装脚本：https://github.com/teddysun/across/raw/master/bbr.sh 检测linux vps是xen openvz还是kvm的方法https://blog.slogra.com/post-632.html SSR客户端MAC客户端： https://github.com/qinyuhang/ShadowsocksX-NG-R/releases Linux客户端：https://raw.githubusercontent.com/the0demiurge/CharlesScripts/master/charles/bin/ssr Windows客户端：https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases IOS客户端：Potatso Lite、Potatso、shadowrocket (需要使用美区apple id下载软件) SSR多用户配置配置文件如下 123456789101112131415161718192021&#123;&quot;server&quot;:&quot;0.0.0.0&quot;,&quot;server_ipv6&quot;: &quot;[::]&quot;,&quot;local_address&quot;:&quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password1&quot;,//着里输入想要的端口和密码 &quot;8990&quot;:&quot;password2&quot;， &quot;8991&quot;:&quot;password3&quot;&#125;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,//加密方式可以修改也可以不修改本人用chacha20&quot;protocol&quot;: &quot;origin&quot;,//协议也是可以修改了本人用auth_sha1&quot;protocol_param&quot;: &quot;&quot;,&quot;obfs&quot;: &quot;plain&quot;,//这里很重要,免流的请注意必须修改,本人用http_simple&quot;obfs_param&quot;: &quot;&quot;,&quot;redirect&quot;: &quot;&quot;,&quot;dns_ipv6&quot;: false,&quot;fast_open&quot;: false,&quot;workers&quot;: 1&#125; 然后修改防火墙，添加上面添加的端口即可，重启防火墙和SSR即可。 参考链接：https://www.cnblogs.com/gne-hwz/p/6662000.html 其他参考 http://blog.sina.com.cn/s/blog_4891cbc50102x5lw.html SSR共享如果你感觉梯子搭建麻烦，也可联系我共享SSR ~~]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
</search>
